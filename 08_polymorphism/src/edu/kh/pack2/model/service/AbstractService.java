package edu.kh.pack2.model.service;

import edu.kh.pack2.model.dto.Animal;
import edu.kh.pack2.model.dto.Dog;
import edu.kh.pack2.model.dto.Snake;

public class AbstractService {
/**
 * 추상 클래스는 진짜로 객체로 못 만드는지 확인해보기
 * 진짜 못만듦! 
 */
public void method1()	{
	//	Animal a = new Animal();
	//Cannot instantiate the type Animal
	//instantiate = 객체화하다
	//추상 클래스 Animal로는 객체화 할 수 없다(객체 생성이 불가능하다)
}
/**
 * 추상 클래스를 상속받은 클래스를 이용해 객체 생성
 * + 다형성(업캐스팅, 동적 바인딩) +객체 배열
 */
public void method2() {
	/*추상 클래스는 객체 생성은 안되지만 부모 타입의 참조변수 역할은 할 수 있다!!!!!
	 * ->동적 바인딩으로 인해
	 * 		자식 객체 내 부모 추상 메서드가 호출될 일은 
	 * 		절대로없다!!!!(컴파일 오류 발생하지 않음)
	 * 		Dog안의 부모 내용 중에 미완성 부분 있어도 문제 없고 그거 쓰지도 않음*/
	//추상클래스는 단독으로 객체 생성은 불가능함!!!
	//하지만 추상클래스를 상속받은 자식 클래스의 객체 생성 시 그 안에 부모 객체로서 생성되는 것은 가능!!!!!
	// 이 때 자식 객체 내부에 존재하는 부모 객체 부분도 같이 생성된다!!!!
	//	->부모 클래스의 추상 메서드(미완성 메서드)는 어떻게 되는가??
	//			->자동으로 자식이 오버라이딩 한 메서드로 자동 동적 바인딩 됨
	//				부모의 eat()와 sleep()은 미완성이니까 자식 것을 참조하라고 동적바인딩 자동으로 됨
	//				부모가 미완성 상태여도 자식 것으로 자동으로 연결(동적바인딩)되니까 프로그램 정상 실행됨
	//	동적 바인딩 == 실제로 참조하고 있는 것의 메서드를 호출하는 것
	Animal a1 = new Dog("포유류", false); //포유류이고 하네스는 없음
	Animal a2 = new Snake("파충류", true); //독이 있음
	Animal a3 = new Dog("포유류", true); //포유류이고 하네스는 없음
	Animal a4 = new Snake("파충류", false); //독이 있음
	
	//부모 타입(Animal) 객체 배열 생성
//	Animal[] arr = new Animal[4];
	Animal[] arr = {a1, a2, a3, a4}; //배열 생성과 동시에 초기화
	
	//향상된 for문 + 동적 바인딩 + print 구문의 특징
	for(Animal a:arr) {
		System.out.println("--------------------------------------------------------------");
		//아래 구문들 모두 동적바인딩 수행됨->실제로 참조하고 있는 객체의 메서드가 호출됨
//		System.out.println(a.toString());
		System.out.println(a);
		//a : 주소가 저장된 참조변수
		//그 주소를 찾아가면 객체가 있음 
		
		//Object.toString()의 목적 : 객체를 문자열로 표현 ==객체의 필드를 모두 모아 하나의 문자열로 변환  
		
		//print() 관련된 구문에 참조 변수를 작성하면 
		//자동으로 toString()메서드를 호출하도록 되어있다!
		//(우리는 그 참조변수에 저장된 주소가 아닌, 그 주소에 있는 객체를 보고싶으니까)
		a.eat();
		a.sleep();
	//추상 클래스 전제 조건 : 상속, 다형성(업캐스팅)
	//추상 클래스 : 추상 메서드를 지닌 클래스, 직접 (단독) 객체 생성 불가능, 부모 타입 참조 변수로는 사용 가능
	//추상 메서드 : 메서드 정의 코드 {}가 없는 메서드 -> 상속받은 자식이 무조건 재정의(오버라이딩) 해야 함 == 오버라이딩 강제화
		//추상클래스를 상속받은 객체 생성 시 
		//자식 객체 내 부모 부분에 존재하는 추상 메서드는 동적 바인딩에 의해 무시된다. 자동으로 자식이 재정의한 메서드로 연결됨 
	}
}
}
